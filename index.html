<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1, maximum-scale=1, viewport-fit=cover">
    <title>ARtedita 3D Viewer</title>
    <!-- Local, version-pinned builds recommended for production -->
    <script src="encantar.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe@1.6.0/dist/aframe-v1.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.2.0/dist/aframe-extras.min.js"></script>
    <script src="aframe-with-encantar.js"></script>

    <!-- Performance Optimization: Cap device pixel ratio -->
    <script>
      (function capDPR () {
        const MAX_DPR = 1.5; // Balance between quality and performance
        const current = window.devicePixelRatio || 1;
        if (current > MAX_DPR) {
          Object.defineProperty(window, 'devicePixelRatio', { get: () => MAX_DPR });
        }
      })();
    </script>
    <style>
        /* Reset */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden; background: transparent;
            font-family: Arial, sans-serif;
            position: fixed; top: 0; left: 0;
        }
        @media (max-width: 768px) {
            html, body { height: 100vh; height: -webkit-fill-available; }
        }

        /* Fullscreen A-Frame/AR with proper z-index hierarchy */
        a-scene, ar-viewport, ar-hud {
            width: 100vw !important;
            height: 100vh !important;
            height: -webkit-fill-available !important;
            position: fixed !important;
            top: 0 !important; left: 0 !important;
        }
        a-scene { z-index: 100 !important; }
        ar-viewport { z-index: 200 !important; background: transparent !important; }
        ar-hud { z-index: 1000 !important; }

        /* Aim overlay glow effect */
        #aim-overlay.glow-exit {
            animation: glowAndFade 1.5s ease-out forwards;
        }
        
        @keyframes glowAndFade {
            0% {
                opacity: 1;
                filter: drop-shadow(0 0 0px #FFD700);
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                opacity: 0.8;
                filter: drop-shadow(0 0 30px #FFD700) drop-shadow(0 0 60px #FFD700);
                transform: translate(-50%, -50%) scale(1.1);
            }
            100% {
                opacity: 0;
                filter: drop-shadow(0 0 50px #FFD700) drop-shadow(0 0 100px #FFD700);
                transform: translate(-50%, -50%) scale(1.3);
            }
        }

        /* Aim overlay (LEGO) */
        #aim-overlay {
            position: fixed !important;
            top: 50% !important; left: 50% !important;
            transform: translate(-50%, -50%) !important;
            width: 80vmin !important; height: auto !important;
            z-index: 1500 !important; pointer-events: none !important;
            transition: opacity .25s ease;
        }
        #aim-overlay svg {
            width: 100% !important;
            height: auto !important;
        }

        /* Enhanced animations */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.3); }
        }
        
        @keyframes progressPulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        @keyframes scanPulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }
        
        @keyframes slideInUp {
            from { transform: translateY(30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes fadeInScale {
            from { transform: scale(0.9); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        /* Missing animations used by JavaScript */
        .fade-out { 
            opacity: 0 !important; 
            transition: opacity 0.5s ease; 
        }
        
        @keyframes fadeIn { 
            from { opacity: 0; } 
            to { opacity: 1; } 
        }
        
        #aim-overlay.hidden { opacity: 0; pointer-events: none; }
        
        /* Enhanced aim overlay with better visibility */
        #aim-overlay {
            animation: fadeInScale 0.5s ease-out;
        }
        
        /* Improved mobile touch targets */
        @media (max-width: 768px) {
            button, .touch-target {
                min-height: 48px;
                padding: 12px 24px;
            }
        }

        /* CRT-style overlay UI */
        #crt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 8000;
            pointer-events: none;
            font-family: 'Courier New', monospace;
        }

        #overlay-hide-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 255, 0, 0.9);
            color: #000;
            border: 2px solid #00ff00;
            padding: 12px 24px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: 600;
            border-radius: 20px;
            cursor: pointer;
            z-index: 2000;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 
                0 0 10px rgba(0, 255, 0, 0.5),
                inset 0 0 10px rgba(0, 255, 0, 0.2);
            transition: all 0.2s ease;
            display: none;
            pointer-events: auto;
            touch-action: manipulation;
        }

        #overlay-hide-btn:hover {
            background: #000;
            color: #00ff00;
            box-shadow: 
                0 0 20px #00ff00,
                inset 0 0 20px rgba(0, 255, 0, 0.3);
        }

        #overlay-hide-btn:active {
            transform: scale(0.95);
        }

        @keyframes crtGlow {
            0% { 
                box-shadow: 
                    0 0 5px #00ff00,
                    inset 0 0 5px rgba(0, 255, 0, 0.2);
            }
            100% { 
                box-shadow: 
                    0 0 15px #00ff00,
                    inset 0 0 15px rgba(0, 255, 0, 0.3);
            }
        }
        
        
        /* Particle burst animation for model unlock */
        .particle-burst {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 300px;
            pointer-events: none;
            z-index: 6000;
        }
        
        .particle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #FFD700;
            border-radius: 50%;
            opacity: 0;
            box-shadow: 0 0 8px #FFD700;
        }
        
        @keyframes sparkBurst {
            0% {
                opacity: 1;
                transform: scale(0) rotate(0deg);
                filter: brightness(2);
            }
            50% {
                opacity: 1;
                filter: brightness(1.5);
            }
            100% {
                opacity: 0;
                transform: scale(1) rotate(360deg);
                filter: brightness(0.5);
            }
        }
        
        @keyframes centerFlash {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0);
                background: radial-gradient(circle, #FFD700 0%, transparent 70%);
            }
            30% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(1.5);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(3);
            }
        }
        
        .center-flash {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 5900;
            animation: centerFlash 1s ease-out;
        }
        
        
        /* Unified button styles - eliminates duplication */
        .ar-button {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            color: #000;
            border: none;
            padding: 1rem 2rem;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
            min-width: 160px;
        }
        
        .ar-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.4);
        }
        
        .ar-button:active {
            transform: translateY(-2px);
        }
        
        
        /* CRT Terminal Loading Screen Styles */
        #custom-loader {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 4000 !important;
            background: #000 !important;
            display: block !important;
        }
        
        .crt-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center, #001100 0%, #000800 50%, #000000 100%);
            border-radius: 0;
            box-shadow: 
                inset 0 0 100px rgba(0, 255, 0, 0.1);
        }
        
        /* Scanlines Effect */
        .crt-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 255, 0, 0.03) 2px,
                rgba(0, 255, 0, 0.03) 4px
            );
            pointer-events: none;
            animation: scanlines 0.1s linear infinite;
        }
        
        /* Screen Flicker */
        @keyframes scanlines {
            0% { opacity: 1; }
            50% { opacity: 0.8; }
            100% { opacity: 1; }
        }
        
        /* Terminal Text Styling */
        .terminal {
            position: absolute;
            top: 35%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #00ff00;
            font-family: 'Courier New', monospace;
        }
        
        .terminal h2 {
            font-size: 2.5rem;
            letter-spacing: 6px;
            margin-bottom: 2rem;
            text-shadow: 
                0 0 5px #00ff00,
                0 0 10px #00ff00,
                0 0 15px #00ff00,
                0 0 20px #00ff00;
            animation: phosphorGlow 2s ease-in-out infinite alternate;
        }
        
        .terminal p {
            font-size: 0.9rem;
            opacity: 0.9;
            text-shadow: 
                0 0 3px #00ff00,
                0 0 6px #00ff00;
            line-height: 1.8;
            letter-spacing: 2px;
        }
        
        /* Phosphor Glow Animation */
        @keyframes phosphorGlow {
            0% { 
                text-shadow: 
                    0 0 5px #00ff00,
                    0 0 10px #00ff00,
                    0 0 15px #00ff00,
                    0 0 20px #00ff00;
            }
            100% { 
                text-shadow: 
                    0 0 8px #00ff00,
                    0 0 16px #00ff00,
                    0 0 24px #00ff00,
                    0 0 32px #00ff00,
                    0 0 40px #00ff00;
            }
        }
        
        /* Terminal Loading Bar */
        .loading-bar-container {
            position: absolute;
            top: 65%;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            text-align: left;
            font-family: 'Courier New', monospace;
        }
        
        .terminal-prompt {
            color: #00ff00;
            font-size: 0.8rem;
            margin-bottom: 10px;
            text-shadow: 0 0 5px #00ff00;
            letter-spacing: 1px;
        }
        
        .loading-bar {
            width: 100%;
            height: 24px;
            background: #001100;
            border: 2px solid #00ff00;
            border-radius: 0;
            position: relative;
            overflow: hidden;
            box-shadow: 
                inset 0 0 10px rgba(0, 255, 0, 0.2),
                0 0 15px rgba(0, 255, 0, 0.3);
        }
        
        .loading-progress {
            height: 100%;
            width: 0%;
            background: repeating-linear-gradient(
                90deg,
                #00ff00 0px,
                #00ff00 3px,
                #00cc00 3px,
                #00cc00 6px
            );
            transition: width 0.2s ease;
            position: relative;
            animation: terminalShimmer 0.8s infinite;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        
        @keyframes terminalShimmer {
            0%, 100% { 
                filter: brightness(1);
                box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            }
            50% { 
                filter: brightness(1.3);
                box-shadow: 0 0 20px rgba(0, 255, 0, 0.8);
            }
        }
        
        .loading-percentage {
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            color: #00ff00;
            margin-top: 15px;
            text-shadow: 0 0 5px #00ff00;
            letter-spacing: 1px;
        }
        
        /* Screen Burn Effect */
        .screen-burn {
            position: absolute;
            top: 30%;
            left: 45%;
            width: 200px;
            height: 50px;
            background: radial-gradient(ellipse, rgba(0, 255, 0, 0.05) 0%, transparent 70%);
            animation: burnFlicker 3s ease-in-out infinite;
        }
        
        @keyframes burnFlicker {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.1; }
        }
        
        /* Responsive design for CRT */
        @media (max-width: 768px) {
            .terminal h2 {
                font-size: 1.5rem;
                letter-spacing: 3px;
            }
            
            .terminal p {
                font-size: 0.7rem;
                letter-spacing: 1px;
            }
            
            .loading-bar-container {
                width: 350px;
            }
            
            .terminal-prompt {
                font-size: 0.7rem;
            }
        }
        
        /* Safe area support for iOS notch/home bar */
        @supports (padding: max(0px)) {
            body {
                padding-top: env(safe-area-inset-top);
                padding-bottom: env(safe-area-inset-bottom);
                padding-left: env(safe-area-inset-left);
                padding-right: env(safe-area-inset-right);
            }
        }
        
        /* Onboarding overlay responsiveness */
        #onboarding-overlay {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            background: #000 !important;
            display: none !important;
            z-index: 9000 !important;
            overflow: hidden !important;
            pointer-events: auto !important;
            visibility: hidden !important;
            opacity: 0 !important;
            transition: opacity 0.5s ease !important;
            /* Safe area padding */
            padding-top: env(safe-area-inset-top, 0px);
            padding-bottom: env(safe-area-inset-bottom, 0px);
            padding-left: env(safe-area-inset-left, 0px);
            padding-right: env(safe-area-inset-right, 0px);
        }
        
        #onboarding-overlay.visible {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        /* Onboarding terminal positioning with safe areas */
        #onboarding-overlay .terminal {
            position: absolute;
            top: calc(10% + env(safe-area-inset-top, 0px));
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            width: 90%;
            max-width: 500px;
        }
        
        /* Onboarding instructions container */
        .onboarding-instructions {
            position: absolute;
            top: calc(35% + env(safe-area-inset-top, 0px));
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            width: 90%;
            max-width: 600px;
            padding: 0 1rem;
        }
        
        .onboarding-instructions .instruction-box {
            border: 2px solid #00ff00;
            padding: 1.5rem;
            background: rgba(0, 17, 0, 0.3);
            box-shadow: 
                inset 0 0 20px rgba(0, 255, 0, 0.1),
                0 0 20px rgba(0, 255, 0, 0.2);
            margin-bottom: 1rem;
        }
        
        .onboarding-instructions h3 {
            font-size: 1.1rem;
            margin-bottom: 1rem;
            text-shadow: 0 0 10px #00ff00;
            letter-spacing: 1.5px;
            color: #00ff00;
        }
        
        .onboarding-instructions p {
            font-size: 0.9rem;
            line-height: 1.5;
            margin-bottom: 1rem;
            letter-spacing: 0.5px;
        }
        
        .onboarding-instructions strong {
            color: #33ff33;
            text-shadow: 0 0 5px #33ff33;
        }
        
        /* Start button with safe area consideration */
        #start-ar-btn {
            background: #001100 !important;
            color: #00ff00 !important;
            border: 2px solid #00ff00 !important;
            padding: 12px 24px !important;
            font-family: 'Courier New', monospace !important;
            font-size: 0.85rem !important;
            letter-spacing: 1.5px !important;
            cursor: pointer !important;
            text-shadow: 0 0 5px #00ff00 !important;
            box-shadow: 
                inset 0 0 10px rgba(0, 255, 0, 0.1),
                0 0 15px rgba(0, 255, 0, 0.3) !important;
            transition: all 0.3s ease !important;
            min-height: 44px !important;
            min-width: 140px !important;
            margin-bottom: env(safe-area-inset-bottom, 0px) !important;
        }
        
        #start-ar-btn:hover, #start-ar-btn:focus {
            background: #002200 !important;
            box-shadow: 
                inset 0 0 15px rgba(0, 255, 0, 0.2),
                0 0 25px rgba(0, 255, 0, 0.5) !important;
        }
        
        /* Responsive breakpoints for small screens */
        @media (max-width: 480px) {
            #onboarding-overlay .terminal h2 {
                font-size: 1.8rem;
                letter-spacing: 2px;
                margin-bottom: 0.5rem;
            }
            
            #onboarding-overlay .terminal p {
                font-size: 0.7rem;
                letter-spacing: 0.5px;
            }
            
            .onboarding-instructions {
                width: 95%;
                padding: 0 0.5rem;
            }
            
            .onboarding-instructions .instruction-box {
                padding: 1rem;
            }
            
            .onboarding-instructions h3 {
                font-size: 0.95rem;
                letter-spacing: 1px;
            }
            
            .onboarding-instructions p {
                font-size: 0.8rem;
                line-height: 1.4;
            }
            
            #start-ar-btn {
                font-size: 0.75rem !important;
                padding: 10px 20px !important;
                letter-spacing: 1px !important;
            }
        }
        
        /* Extra small screens (iPhone SE - 320px) */
        @media (max-width: 360px) {
            #onboarding-overlay .terminal {
                top: calc(8% + env(safe-area-inset-top, 0px));
                width: 95%;
            }
            
            #onboarding-overlay .terminal h2 {
                font-size: 1.5rem;
                letter-spacing: 1px;
                margin-bottom: 0.3rem;
            }
            
            #onboarding-overlay .terminal p {
                font-size: 0.6rem;
                letter-spacing: 0px;
            }
            
            .onboarding-instructions {
                top: calc(30% + env(safe-area-inset-top, 0px));
                width: 98%;
                padding: 0 0.25rem;
            }
            
            .onboarding-instructions .instruction-box {
                padding: 0.8rem;
            }
            
            .onboarding-instructions h3 {
                font-size: 0.85rem;
                letter-spacing: 0.5px;
                margin-bottom: 0.8rem;
            }
            
            .onboarding-instructions p {
                font-size: 0.75rem;
                line-height: 1.3;
                margin-bottom: 0.8rem;
            }
            
            #start-ar-btn {
                font-size: 0.7rem !important;
                padding: 8px 16px !important;
                letter-spacing: 0.5px !important;
                min-width: 120px !important;
            }
        }
        
        /* Landscape orientation adjustments */
        @media (orientation: landscape) and (max-height: 500px) {
            #onboarding-overlay .terminal {
                top: calc(5% + env(safe-area-inset-top, 0px));
            }
            
            #onboarding-overlay .terminal h2 {
                font-size: 1.3rem;
                margin-bottom: 0.3rem;
            }
            
            #onboarding-overlay .terminal p {
                font-size: 0.6rem;
            }
            
            .onboarding-instructions {
                top: calc(25% + env(safe-area-inset-top, 0px));
            }
            
            .onboarding-instructions .instruction-box {
                padding: 1rem;
            }
            
            .onboarding-instructions h3 {
                font-size: 0.9rem;
                margin-bottom: 0.8rem;
            }
            
            .onboarding-instructions p {
                font-size: 0.75rem;
                line-height: 1.3;
                margin-bottom: 0.8rem;
            }
        }
    </style>
</head>

<body>

<script>
    // ===== SINGLE SOURCE OF TRUTH: MODEL POSE CONFIGURATIONS =====
    // 
    // âš ï¸  CRITICAL: This is the ONLY place to define model poses for HUD clones.
    // âš ï¸  Changes here will immediately affect the visible models.
    // âš ï¸  DO NOT set poses anywhere else - they will be overridden by this config.
    //
    // ðŸŽ¯ USAGE: To adjust frog size/position, edit the 'frog-scene' values below.
    //          The HUD clone will always use these exact values.
    //
    // ðŸ”’ PROTECTION: HUD clones are wrapped in containers and stripped of competing
    //               transform components (smooth-pose, conflicting animations).
    //
    // ðŸ”„ LIFECYCLE: Applied fresh on every scanâ†’show cycle, no drift or overrides.
    //
    const MODEL_POSE_CONFIG = {
      'face-scene': {
        position: { x: 0, y: -0.5, z: -2 },
        scale: { x: 0.8, y: 0.8, z: 0.8 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      'frog-scene': {
        // ðŸ¸ FROG POSE TUNING KNOB - Edit these values to adjust visible frog
        position: { x: 0, y: -0.7, z: -2.2 },  // Camera-relative position (slightly closer & higher)
        scale: { x: 1.0, y: 1.0, z: 1.0 },     // Size multiplier (normalized size)
        rotation: { x: 0, y: 15, z: 0 }         // Euler angles (slight Y rotation for testing)
      }
    };

    // State Machine-Based Scene Management System
    const TARGET_TO_SCENE = {
      'face-target': 'face-scene',
      'frog-target': 'frog-scene'
    };

    const AppState = {
      SCANNING: 'SCANNING',
      SHOWING: 'SHOWING'
    };

    const SceneManager = {
      state: AppState.SCANNING,
      scenes: {},
      currentSceneId: null,
      currentHudModel: null,
      
      init() {
        // Cache scene elements
        this.scenes = {
          'face-scene': document.getElementById('face-scene'),
          'frog-scene': document.getElementById('frog-scene')
        };
        
        // Validate all scenes exist
        Object.entries(this.scenes).forEach(([id, el]) => {
          if (!el) {
            console.error(`ðŸŽ¬ Scene element not found: ${id}`);
          }
        });
        
        // Setup event listeners for target detection only
        document.addEventListener('artargetfound', this.onTargetFound.bind(this));
        // Note: Deliberately NOT listening to artargetlost for persistence
        
        console.log('ðŸŽ¬ Scene Manager initialized in SCANNING state');
      },
      
      onTargetFound(ev) {
        const ref = ev.detail && ev.detail.referenceImage;
        console.log('ðŸŽ¬ SceneManager - Target found:', ref ? ref.name : 'none');
        
        // Guard against double spawns - only process if SCANNING
        if (this.state !== AppState.SCANNING) {
          console.log('ðŸŽ¬ Already DISPLAYING - ignoring target found');
          return;
        }
        
        if (ref && TARGET_TO_SCENE[ref.name]) {
          const sceneId = TARGET_TO_SCENE[ref.name];
          console.log(`ðŸŽ¬ Reparenting model to camera HUD for: ${ref.name}`);
          
          // Reparent model to camera HUD for true persistence
          this.reparentModelToHUD(sceneId, ref.name);
          
          // Update state to DISPLAYING
          this.state = AppState.SHOWING;
          
          // Show hide button
          this.showOverlayHideButton();
          
          // Debug log target detection (removed visible UI)
          const targetDisplayName = ref.name === 'face-target' ? 'Face Model' : 'Moonwalk Animation';
          console.debug('ðŸŽ¯ Target detected for display:', targetDisplayName);
          
          // Hide aim overlay
          const aimOverlay = document.getElementById('aim-overlay');
          if (aimOverlay) {
            aimOverlay.style.transition = 'opacity 1s ease-out';
            aimOverlay.style.opacity = '0';
            setTimeout(() => aimOverlay.style.display = 'none', 1000);
          }
          
          // Trigger particle burst once per session
          if (window.ARtedita && !ARtedita.state.modelAnchored && ARtedita.triggerParticleBurst) {
            ARtedita.triggerParticleBurst();
            ARtedita.state.modelAnchored = true;
          }
          
          console.log('ðŸŽ¬ Model reparented to HUD - decoupled from marker');
        }
      },
      
      reparentModelToHUD(sceneId, targetName) {
        const hudRoot = document.getElementById('hud-root');
        const originalScene = this.scenes[sceneId];
        
        if (!hudRoot || !originalScene) {
          console.error('ðŸŽ¬ HUD root or original scene not found');
          return;
        }
        
        // Find the model element within the scene
        let modelElement;
        if (sceneId === 'face-scene') {
          modelElement = originalScene.querySelector('#face-model');
        } else if (sceneId === 'frog-scene') {
          modelElement = originalScene.querySelector('#moonwalk-model');
        }
        
        if (!modelElement) {
          console.error(`ðŸŽ¬ Model element not found in ${sceneId}`);
          return;
        }
        
        // Clone the model to avoid disrupting the original
        const hudModel = modelElement.cloneNode(true);
        hudModel.id = `hud-${modelElement.id}`;
        
        // CRITICAL: Remove any competing transform components from HUD clone
        // These would override our canonical pose configuration
        hudModel.removeAttribute('smooth-pose');
        hudModel.removeAttribute('animation');
        hudModel.removeAttribute('animation-mixer'); // Keep animations but not transforms
        
        // Re-add only the animation-mixer for model animations (not transforms)
        if (sceneId === 'frog-scene') {
          hudModel.setAttribute('animation-mixer', 'clip: *');
        } else if (sceneId === 'face-scene') {
          // Face model keeps its rotation animation
          hudModel.setAttribute('animation', 'property: rotation; to: 0 360 0; loop: true; dur: 5000');
        }
        
        // Handle GLB root offsets by wrapping model in a container
        // This ensures our canonical pose is applied to the container, not affected by GLB pivot points
        const hudContainer = document.createElement('a-entity');
        hudContainer.id = `hud-container-${modelElement.id}`;
        
        // Reset model to origin within container (neutralize GLB offsets)
        hudModel.setAttribute('position', '0 0 0');
        hudModel.setAttribute('scale', '1 1 1');
        hudModel.setAttribute('rotation', '0 0 0');
        
        // Apply canonical pose to CONTAINER (single source of truth)
        const poseConfig = MODEL_POSE_CONFIG[sceneId];
        if (poseConfig) {
          const pos = poseConfig.position;
          const scale = poseConfig.scale;
          const rot = poseConfig.rotation;
          
          hudContainer.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
          hudContainer.setAttribute('scale', `${scale.x} ${scale.y} ${scale.z}`);
          hudContainer.setAttribute('rotation', `${rot.x} ${rot.y} ${rot.z}`);
          
          console.log(`ðŸŽ¯ Applied canonical pose to ${sceneId} HUD container:`, {
            position: `${pos.x} ${pos.y} ${pos.z}`,
            scale: `${scale.x} ${scale.y} ${scale.z}`,
            rotation: `${rot.x} ${rot.y} ${rot.z}`
          });
        } else {
          console.warn(`âš ï¸ No pose config found for ${sceneId}`);
        }
        
        // Nest model inside container
        hudContainer.appendChild(hudModel);
        
        // Add lighting for the HUD model
        const ambientLight = document.createElement('a-light');
        ambientLight.setAttribute('type', 'ambient');
        ambientLight.setAttribute('color', '#ffffff');
        ambientLight.setAttribute('intensity', '2.5');
        
        const directionalLight = document.createElement('a-light');
        directionalLight.setAttribute('type', 'directional');
        directionalLight.setAttribute('position', '2 4 2');
        directionalLight.setAttribute('color', '#ffffff');
        directionalLight.setAttribute('intensity', '3.0');
        
        // Append container (with nested model) to HUD root
        hudRoot.appendChild(hudContainer);
        hudRoot.appendChild(ambientLight);
        hudRoot.appendChild(directionalLight);
        
        // Track current HUD model
        this.currentHudModel = hudModel;
        this.currentSceneId = sceneId;
        
        console.log(`ðŸŽ¬ Model ${modelElement.id} reparented to HUD at fixed position`);
      },
      
      
      
      onHideClicked() {
        console.log('ðŸŽ¬ HIDE BUTTON CLICKED - HANDLER EXECUTING!');
        console.log('ðŸŽ¬ Hide button clicked - triggering target lost behavior');
        
        // Hide the hide button first
        this.hideOverlayHideButton();
        
        // Remove current HUD model and lighting
        if (this.currentHudModel) {
          // Remove the model
          this.currentHudModel.remove();
          this.currentHudModel = null;
          
          // Clear all lighting from HUD root
          const hudRoot = document.getElementById('hud-root');
          if (hudRoot) {
            const lights = hudRoot.querySelectorAll('a-light');
            lights.forEach(light => light.remove());
          }
        }
        
        // Debug log target hiding (removed visible UI)
        console.debug('ðŸŽ¯ Target indicator hidden (UI removed)');
        
        // Update state to SCANNING
        this.state = AppState.SCANNING;
        
        // Show aim overlay again for scanning
        const aimOverlay = document.getElementById('aim-overlay');
        if (aimOverlay) {
          aimOverlay.style.display = 'block';
          aimOverlay.style.opacity = '1';
          aimOverlay.classList.remove('hidden');
        }
        
        // Reset model anchored state and return to scanning
        if (window.ARtedita && window.ARtedita.state) {
          window.ARtedita.state.modelAnchored = false;
        }
        
        // Resume scanning animation
        if (typeof playOverlay === 'function') {
          playOverlay();
        }
        
        // TODO: Add explicit Encantar session restart when method is identified
        // For now, rely on natural AR session continuation
        
        this.currentSceneId = null;
        console.log('ðŸŽ¬ HUD model removed - returned to SCANNING mode');
      },
      
      showOverlayHideButton() {
        const hideBtn = document.getElementById('overlay-hide-btn');
        if (hideBtn) {
          hideBtn.style.display = 'block';
          console.log('ðŸŽ¬ Hide button shown');
        }
      },
      
      hideOverlayHideButton() {
        const hideBtn = document.getElementById('overlay-hide-btn');
        if (hideBtn) {
          hideBtn.style.display = 'none';
          console.log('ðŸŽ¬ Hide button hidden');
        }
      }
      
    };
    
    // Initialize after DOM is ready to ensure elements exist
    let hideButtonBound = false;
    
    document.addEventListener('DOMContentLoaded', () => {
      console.log('ðŸŽ¬ Initializing SceneManager after DOMContentLoaded...');
      SceneManager.init();
      
      // Guard against double-binding
      if (hideButtonBound) {
        console.log('ðŸŽ¬ Hide button already bound, skipping');
        return;
      }
      
      // Debug: Check if button exists in DOM
      const hideBtn = document.getElementById('overlay-hide-btn');
      console.log('ðŸŽ¬ Hide button found:', !!hideBtn, hideBtn);
      
      if (hideBtn) {
        // Handler function to prevent double execution
        let isHandling = false;
        const handleHideClick = (event) => {
          if (isHandling) {
            console.log('ðŸŽ¬ Already handling click, ignoring');
            return;
          }
          isHandling = true;
          
          console.log('ðŸŽ¬ HIDE EVENT FIRED!', event.type, event);
          event.preventDefault();
          event.stopPropagation();
          
          SceneManager.onHideClicked();
          
          // Reset handling flag after execution
          setTimeout(() => { isHandling = false; }, 100);
        };
        
        // Add both click and touchend for mobile reliability
        hideBtn.addEventListener('click', handleHideClick);
        hideBtn.addEventListener('touchend', handleHideClick);
        
        hideButtonBound = true;
        console.log('ðŸŽ¬ Hide button handlers bound (click + touchend)');
        
        // Test button is clickable
        const computedStyle = getComputedStyle(hideBtn);
        console.log('ðŸŽ¬ Button styles:', {
          display: hideBtn.style.display,
          pointerEvents: computedStyle.pointerEvents,
          zIndex: computedStyle.zIndex,
          position: computedStyle.position,
          touchAction: computedStyle.touchAction
        });
      } else {
        console.error('ðŸŽ¬ CRITICAL: Hide button not found in DOM!');
      }
    });
</script>

<script>
  // ARtedita Application Namespace - eliminates global variable pollution
  window.ARtedita = {
    state: {
      loadingProgress: 0,
      stepIndex: 0,
      isReady: false,
      overlayPaused: false
    },
    
    // DOM elements cache
    elements: {},
    
    
    // Initialize DOM elements cache
    initElements() {
      this.elements = {
        scene: document.querySelector('a-scene'),
        aimOverlay: document.getElementById('aim-overlay'),
        customLoader: document.getElementById('custom-loader'),
        progressBar: document.getElementById('progress-bar')
      };
    }
  };

  // Enhanced UX management with loading and status feedback
  document.addEventListener('DOMContentLoaded', () => {
    ARtedita.initElements();
    const { scene, aimOverlay, customLoader, progressBar } = ARtedita.elements;
    
    // Terminal loading steps
    ARtedita.loadingSteps = [
      { progress: 15, delay: 400, text: 'INITIALIZING SYSTEM...' },
      { progress: 35, delay: 600, text: 'LOADING CORE LIBRARIES...' },
      { progress: 55, delay: 800, text: 'PREPARING AR FRAMEWORK...' },
      { progress: 75, delay: 700, text: 'LOADING 3D ASSETS...' },
      { progress: 90, delay: 500, text: 'CONFIGURING CAMERA...' },
      { progress: 100, delay: 600, text: 'SYSTEM READY' }
    ];
    
    ARtedita.updateProgress = (progress) => {
      ARtedita.state.loadingProgress = Math.min(progress, 100);
      if (progressBar) {
        progressBar.style.width = ARtedita.state.loadingProgress + '%';
      }
      // Update terminal percentage display
      const loadingPercentage = document.getElementById('loading-percentage');
      if (loadingPercentage) {
        loadingPercentage.textContent = `] ${Math.floor(ARtedita.state.loadingProgress)}% COMPLETE`;
      }
    };
    
    ARtedita.processLoadingStep = () => {
      if (ARtedita.state.stepIndex < ARtedita.loadingSteps.length) {
        const step = ARtedita.loadingSteps[ARtedita.state.stepIndex];
        ARtedita.updateProgress(step.progress);
        
        // Update terminal loading text
        const loadingText = document.getElementById('loading-text');
        if (loadingText) loadingText.textContent = step.text;
        
        ARtedita.state.stepIndex++;
        setTimeout(ARtedita.processLoadingStep, step.delay);
      } else {
        // Final completion state
        const loadingPercentage = document.getElementById('loading-percentage');
        if (loadingPercentage) {
          loadingPercentage.textContent = '] 100% COMPLETE - SYSTEM READY';
        }
      }
    }
    
    ARtedita.processLoadingStep();
    
    // Truthful loader - wait for all real readiness conditions
    ARtedita.readinessChecks = {
      sceneLoaded: false,
      assetsLoaded: false,
      cameraReady: false,
      arSessionReady: false
    };
    
    ARtedita.checkAllReady = () => {
      const { sceneLoaded, assetsLoaded, cameraReady, arSessionReady } = ARtedita.readinessChecks;
      console.log('Readiness status:', ARtedita.readinessChecks);
      
      if (sceneLoaded && assetsLoaded && cameraReady && arSessionReady) {
        console.log('All systems ready - hiding loader');
        if (!ARtedita.state.loaderHidden) {
          ARtedita.state.loaderHidden = true;
          ARtedita.hideLoaderAndShowOnboarding();
        }
      }
    };
    
    ARtedita.waitForARReady = () => {
      console.log('Waiting for all AR system components to be ready...');
      
      // 1. Check A-Frame scene loading
      const checkSceneReady = () => {
        const scene = document.querySelector('a-scene');
        if (!scene) {
          console.log('A-Frame scene not found, waiting...');
          setTimeout(checkSceneReady, 100);
          return;
        }
        
        if (!scene.hasLoaded) {
          console.log('A-Frame scene not loaded yet, waiting...');
          scene.addEventListener('loaded', () => {
            console.log('âœ“ A-Frame scene loaded');
            ARtedita.readinessChecks.sceneLoaded = true;
            ARtedita.checkAllReady();
          });
        } else {
          console.log('âœ“ A-Frame scene already loaded');
          ARtedita.readinessChecks.sceneLoaded = true;
          ARtedita.checkAllReady();
        }
      };
      
      // 2. Check asset loading
      const checkAssetsReady = () => {
        const assets = document.querySelector('a-assets');
        if (assets) {
          if (assets.hasLoaded) {
            console.log('âœ“ Assets already loaded');
            ARtedita.readinessChecks.assetsLoaded = true;
            ARtedita.checkAllReady();
          } else {
            assets.addEventListener('loaded', () => {
              console.log('âœ“ Assets loaded');
              ARtedita.readinessChecks.assetsLoaded = true;
              ARtedita.checkAllReady();
            });
          }
        } else {
          // No assets element, consider ready
          console.log('âœ“ No assets to load');
          ARtedita.readinessChecks.assetsLoaded = true;
          ARtedita.checkAllReady();
        }
      };
      
      // 3. Check camera stream ready
      const checkCameraReady = () => {
        const arCamera = document.querySelector('ar-camera-source');
        if (arCamera) {
          // Listen for camera stream ready
          arCamera.addEventListener('loadstart', () => {
            console.log('âœ“ Camera stream ready');
            ARtedita.readinessChecks.cameraReady = true;
            ARtedita.checkAllReady();
          });
          
          // Fallback: check if camera is already ready
          setTimeout(() => {
            if (!ARtedita.readinessChecks.cameraReady) {
              console.log('âœ“ Camera ready (fallback)');
              ARtedita.readinessChecks.cameraReady = true;
              ARtedita.checkAllReady();
            }
          }, 2000);
        } else {
          console.log('âœ“ No AR camera found, skipping');
          ARtedita.readinessChecks.cameraReady = true;
          ARtedita.checkAllReady();
        }
      };
      
      // 4. Check AR session ready (encantar's arready event)
      const checkARSessionReady = () => {
        const scene = document.querySelector('a-scene');
        if (scene) {
          scene.addEventListener('arready', () => {
            console.log('âœ“ AR session ready');
            ARtedita.readinessChecks.arSessionReady = true;
            ARtedita.checkAllReady();
          });
        }
      };
      
      // Start all checks
      setTimeout(() => {
        checkSceneReady();
        checkAssetsReady();
        checkCameraReady();
        checkARSessionReady();
      }, 1000);
    };
    
    ARtedita.fixModelPositions = () => {
      // Fix position/scale corruption after AR ready
      setTimeout(() => {
        const moonwalkModel = document.getElementById('moonwalk-model');
        const faceModel = document.getElementById('face-model');
        
        if (moonwalkModel) {
          moonwalkModel.object3D.position.set(0, -1.2, 0);
          moonwalkModel.object3D.scale.set(0.8, 0.8, 0.8);
          console.log('Fixed moonwalk model positioning');
        }
        
        if (faceModel) {
          faceModel.object3D.position.set(0, -1, 0);
          faceModel.object3D.scale.set(1, 1, 1);
          console.log('Fixed face model positioning');
        }
      }, 500);
    };
    
    ARtedita.hideLoaderAndShowOnboarding = () => {
      console.log('All systems ready - hiding loader and showing onboarding');
      const customLoader = document.getElementById('custom-loader');
      
      if (customLoader && customLoader.style.display !== 'none') {
        // Fix model positions now that AR is ready
        ARtedita.fixModelPositions();
        
        // Ensure onboarding is completely hidden during loader fade
        ARtedita.hideOnboarding();
        
        // Hide loader with fade effect
        customLoader.classList.add('fade-out');
        customLoader.style.opacity = '0';
        
        setTimeout(() => {
          // Completely remove loader from DOM
          customLoader.style.display = 'none';
          customLoader.style.visibility = 'hidden';
          
          // Show onboarding only after loader is completely hidden
          setTimeout(() => {
            ARtedita.showOnboarding();
          }, 100);
        }, 500);
      } else {
        // Loader already hidden, show onboarding directly
        ARtedita.showOnboarding();
      }
    };
    
    ARtedita.showOnboarding = () => {
      console.log('Showing onboarding overlay');
      const customLoader = document.getElementById('custom-loader');
      const onboardingOverlay = document.getElementById('onboarding-overlay');
      
      // Double-check loader is hidden before showing onboarding
      if (customLoader && (customLoader.style.display !== 'none' || customLoader.style.visibility !== 'hidden')) {
        console.log('Loader still visible, delaying onboarding');
        setTimeout(() => ARtedita.showOnboarding(), 200);
        return;
      }
      
      if (onboardingOverlay) {
        console.log('Making onboarding overlay visible');
        // Force visibility with all necessary properties
        onboardingOverlay.style.display = 'block';
        onboardingOverlay.style.visibility = 'visible';
        onboardingOverlay.style.opacity = '1';
        onboardingOverlay.classList.add('visible');
        onboardingOverlay.classList.remove('fade-out');
        
        // Verify it's actually visible
        const computedStyle = getComputedStyle(onboardingOverlay);
        console.log('Onboarding overlay computed styles:', {
          display: computedStyle.display,
          visibility: computedStyle.visibility,
          opacity: computedStyle.opacity,
          zIndex: computedStyle.zIndex
        });
      } else {
        console.error('Onboarding overlay element not found!');
      }
    };
    
    ARtedita.hideOnboarding = () => {
      console.log('Hiding onboarding overlay');
      const onboardingOverlay = document.getElementById('onboarding-overlay');
      if (onboardingOverlay) {
        // Immediately hide without animation for clean state
        onboardingOverlay.classList.remove('visible');
        onboardingOverlay.classList.add('fade-out');
        onboardingOverlay.style.opacity = '0';
        onboardingOverlay.style.visibility = 'hidden';
        
        setTimeout(() => {
          onboardingOverlay.style.display = 'none';
          onboardingOverlay.classList.remove('fade-out');
        }, 500);
      }
    };
    
    // Start real AR loading detection
    ARtedita.waitForARReady();
    
    
    
    
    
    
    
    // Enhanced AR event handling
    if (scene && aimOverlay) {
      // Overlay animations management
      const overlayAnims = aimOverlay.querySelectorAll('.stroke-main, .stroke-halo');
      const pauseOverlay = () => overlayAnims.forEach(n => n.style.animationPlayState = 'paused');
      const playOverlay = () => overlayAnims.forEach(n => n.style.animationPlayState = 'running');
      
      // AR session events
      scene.addEventListener('enter-vr', () => {
      });
      
      // AR ready event - remove duplicate handler
      // (Main AR ready handling is now in checkARComponents)
      
      // Persistent model tracking - anchor after first detection
      let modelAnchored = false;
      
      // Browser compatibility check
      ARtedita.checkBrowserSupport = () => {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          ARtedita.showError('Camera access not supported in this browser. Please use a modern mobile browser.');
          return false;
        }
        return true;
      };
      
      ARtedita.showError = (message) => {
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
          position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
          background: #ff4444; color: white; padding: 20px; border-radius: 10px;
          text-align: center; z-index: 9999; max-width: 80%;
        `;
        errorDiv.textContent = message;
        document.body.appendChild(errorDiv);
      };
      
      // Check browser support on load
      if (!ARtedita.checkBrowserSupport()) {
        return;
      };
      
      // Particle burst animation for unlock effect
      ARtedita.triggerParticleBurst = () => {
        console.log('Triggering particle burst animation');
        
        // Create center flash
        const centerFlash = document.createElement('div');
        centerFlash.className = 'center-flash';
        document.body.appendChild(centerFlash);
        
        // Create particle container
        const burstContainer = document.createElement('div');
        burstContainer.className = 'particle-burst';
        document.body.appendChild(burstContainer);
        
        // Create particles
        const particleCount = 20;
        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          
          // Random position within container
          const angle = (i / particleCount) * 2 * Math.PI + (Math.random() - 0.5) * 0.5;
          const distance = 50 + Math.random() * 100;
          const x = Math.cos(angle) * distance;
          const y = Math.sin(angle) * distance;
          
          particle.style.left = `calc(50% + ${x}px)`;
          particle.style.top = `calc(50% + ${y}px)`;
          
          // Random animation timing
          const delay = Math.random() * 0.3;
          const duration = 1.2 + Math.random() * 0.8;
          
          // Random gold tones
          const goldTones = ['#FFD700', '#FFA500', '#FF8C00', '#DAA520', '#B8860B'];
          const color = goldTones[Math.floor(Math.random() * goldTones.length)];
          particle.style.background = color;
          particle.style.boxShadow = `0 0 8px ${color}`;
          
          particle.style.animation = `sparkBurst ${duration}s ease-out ${delay}s forwards`;
          
          burstContainer.appendChild(particle);
        }
        
        // Clean up after animation
        setTimeout(() => {
          centerFlash.remove();
          burstContainer.remove();
        }, 2000);
      };
      
      
      
      // Error handling
      scene.addEventListener('ar-error', (ev) => {
        console.error('AR Error:', ev.detail);
        ARtedita.showError('AR initialization failed. Please check camera permissions and try again.');
      });
      
      // Let encantar/A-Frame drive permission flow; surface errors via ar-error (already handled).
      // Camera ready event - use AR stack instead of manual getUserMedia
      scene.addEventListener('arready', () => {
      });
    }
    
    // Performance monitoring
    let frameCount = 0;
    let lastTime = performance.now();
    
    const monitorPerformance = () => {
      frameCount++;
      const currentTime = performance.now();
      
      if (currentTime - lastTime >= 5000) { // Check every 5 seconds
        const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
        
        if (fps < 20) {
        }
        
        frameCount = 0;
        lastTime = currentTime;
      }
      
      requestAnimationFrame(monitorPerformance);
    };
    
    // Start performance monitoring
    requestAnimationFrame(monitorPerformance);
  });
</script>

<body>
    <!-- CRT Terminal Loading Screen -->
    <div id="custom-loader">
        <div class="crt-screen">
            <!-- Screen Burn Effect -->
            <div class="screen-burn"></div>
            
            <!-- Terminal Text -->
            <div class="terminal">
                <h2>ARtEdita</h2>
                <p id="loading-text">INITIALIZING SYSTEM...</p>
            </div>
            
            <!-- Terminal Loading Bar -->
            <div class="loading-bar-container">
                <div class="terminal-prompt">LOADING: [</div>
                <div class="loading-bar">
                    <div class="loading-progress" id="progress-bar"></div>
                </div>
                <div class="loading-percentage" id="loading-percentage">] 0% COMPLETE</div>
            </div>
        </div>
    </div>








    <!-- A-Frame AR Scene -->
    <a-scene encantar="stats: false; gizmos: false" device-orientation-permission-ui="enabled: false" background="transparent: true">          
        <!-- Asset preloading -->
        <a-assets>
            <a-asset-item id="face-model-asset" src="base_basic_shaded.glb"></a-asset-item>
            <a-asset-item id="moonwalk-model-asset" src="moonwalk.glb"></a-asset-item>
        </a-assets>

        <!-- Sources of data -->
        <ar-sources>
            <ar-camera-source resolution="lg" facing-mode="environment"></ar-camera-source>
        </ar-sources>

        <!-- Trackers -->
        <ar-trackers>
            <ar-image-tracker resolution="lg" database-size="lg">
                <ar-reference-image name="face-target" src="reference.png"></ar-reference-image>
                <ar-reference-image name="frog-target" src="reference2.png"></ar-reference-image>
            </ar-image-tracker>
        </ar-trackers>

        <!-- AR Viewport -->
        <ar-viewport>
            <ar-hud>
                <!-- LEGO head aim overlay -->
                <div id="aim-overlay">
  <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" style="background:none">
    <defs>
      <filter id="haloLite" x="-30%" y="-30%" width="160%" height="160%">
        <feGaussianBlur in="SourceGraphic" stdDeviation="5" />
      </filter>
      
      <!-- CRT Scanlines Pattern -->
      <pattern id="crtScanlines" x="0" y="0" width="100" height="4" patternUnits="userSpaceOnUse">
        <rect width="100" height="2" fill="rgba(0, 255, 0, 0.03)"/>
        <rect y="2" width="100" height="2" fill="transparent"/>
      </pattern>
      
      <!-- CRT Background Gradient -->
      <radialGradient id="crtBackground" cx="50%" cy="50%" r="70%">
        <stop offset="0%" stop-color="#001100" stop-opacity="0.8"/>
        <stop offset="50%" stop-color="#000800" stop-opacity="0.9"/>
        <stop offset="100%" stop-color="#000000" stop-opacity="1"/>
      </radialGradient>
      
      <!-- Combined CRT Fill -->
      <pattern id="crtFill" x="0" y="0" width="100" height="100" patternUnits="userSpaceOnUse">
        <rect width="100" height="100" fill="url(#crtBackground)"/>
        <rect width="100" height="100" fill="url(#crtScanlines)"/>
      </pattern>
    </defs>

    <style>
      .stroke-main {
        /* animation + styling still via CSS */
        stroke: #00ff00;
        stroke-width: 4.5;
        vector-effect: non-scaling-stroke;
        stroke-linejoin: round;
        stroke-linecap: round;
        animation: mainPulse 2.2s ease-in-out infinite;
      }
      .stroke-halo {
        stroke: #00ff00;
        stroke-width: 11;
        opacity: .5;
        vector-effect: non-scaling-stroke;
        stroke-linejoin: round;
        stroke-linecap: round;
        animation: haloPulse 2.2s ease-in-out infinite;
      }
      @keyframes mainPulse {
        0% { stroke: #00ff00; }
        50% { stroke: #33ff33; }
        100% { stroke: #00ff00; }
      }
      @keyframes haloPulse {
        0% { opacity: .4; stroke: #00cc00; }
        50% { opacity: .75; stroke: #33ff33; }
        100% { opacity: .4; stroke: #00cc00; }
      }
      
      /* CRT Scanning effect */
      @keyframes scanLine {
        0% { transform: translateY(0px); opacity: 0.8; }
        50% { opacity: 1; }
        100% { transform: translateY(60px); opacity: 0.8; }
      }
      @media (prefers-reduced-motion: reduce) {
        .stroke-main, .stroke-halo { animation: none; }
      }
    </style>

    <!-- CRT Background Fill -->
    <g fill="url(#crtFill)" fill-opacity="0.9">
      <rect x="15" y="20" width="70" height="60" rx="18" ry="18"/>
      <rect x="38" y="10" width="24" height="12" rx="3" ry="3"/>
      <rect x="33" y="80" width="34" height="10" rx="3" ry="3"/>
    </g>
    
    <!-- Animated Scanning Line -->
    <g>
      <line x1="33" y1="38" x2="67" y2="38" stroke="#00ff00" stroke-width="0.5" opacity="0.8">
        <animateTransform attributeName="transform" type="translate" 
                         values="0,0; 0,24; 0,0" dur="2s" repeatCount="indefinite"/>
        <animate attributeName="opacity" values="0.8;1;0.8" dur="2s" repeatCount="indefinite"/>
      </line>
    </g>

    <!-- HALO: force no fill via attribute -->
    <g style="filter:url(#haloLite);">
      <rect class="stroke-halo" x="15" y="20" width="70" height="60" rx="18" ry="18" fill="none"/>
      <rect class="stroke-halo" x="38" y="10" width="24" height="12" rx="3" ry="3" fill="none"/>
      <rect class="stroke-halo" x="33" y="80" width="34" height="10" rx="3" ry="3" fill="none"/>
    </g>

    <!-- OUTLINE: force no fill via attribute -->
    <g>
      <rect class="stroke-main" x="15" y="20" width="70" height="60" rx="18" ry="18" fill="none"/>
      <rect class="stroke-main" x="38" y="10" width="24" height="12" rx="3" ry="3" fill="none"/>
      <rect class="stroke-main" x="33" y="80" width="34" height="10" rx="3" ry="3" fill="none"/>
    </g>
  </svg>
            </div>
        </ar-hud>
    </ar-viewport>

    <!-- AR Camera -->
    <ar-camera>
        <a-entity id="hud-root" position="0 0 0"></a-entity>
    </ar-camera>

        <!-- Face Target AR Scene -->
        <ar-root id="face-scene" reference-image="face-target" visible="false">
            <!-- Smoothed container for stability -->
            <a-entity id="face-smoothed" smooth-pose="pos:0.18; rot:0.18; scale:0.22">
              <a-gltf-model id="face-model"
                            src="#face-model-asset"
                            position="0 -1 0"
                            scale="1 1 1"
                            animation="property: rotation; to: 0 360 0; loop: true; dur: 5000"
                            shadow="cast: true; receive: true">
              </a-gltf-model>

              <a-light type="ambient" color="#ffffff" intensity="2.51"></a-light>
              <a-light type="directional" position="2 4 2" color="#ffffff" intensity="3.14" shadow="cast: true"></a-light>
              <a-light type="point" position="-1 2 1" color="#4CAF50" intensity="30" decay="2"></a-light>
              <a-light type="point" position="1 2 1" color="#2196F3" intensity="30" decay="2"></a-light>
            </a-entity>
        </ar-root>

        <!-- Frog Target AR Scene -->
        <ar-root id="frog-scene" reference-image="frog-target" visible="false">
            <!-- Smoothed container for stability -->
            <a-entity id="frog-smoothed" smooth-pose="pos:0.18; rot:0.18; scale:0.22">
              <a-gltf-model id="moonwalk-model"
                            src="#moonwalk-model-asset"
                            position="0 -1.2 0"
                            scale="0.8 0.8 0.8"
                            animation-mixer="clip: *"
                            shadow="cast: true; receive: true">
              </a-gltf-model>

              <a-light type="ambient" color="#ffffff" intensity="2.51"></a-light>
              <a-light type="directional" position="2 4 2" color="#ffffff" intensity="3.14" shadow="cast: true"></a-light>
              <a-light type="point" position="-1 2 1" color="#4CAF50" intensity="30" decay="2"></a-light>
              <a-light type="point" position="1 2 1" color="#2196F3" intensity="30" decay="2"></a-light>
            </a-entity>
        </ar-root>

    </a-scene>

    <!-- CRT-style overlay UI -->
    <div id="crt-overlay">
        <button id="overlay-hide-btn">
            [ HIDE ]
        </button>
    </div>

<!-- Pose smoothing component -->
<script>
AFRAME.registerComponent('smooth-pose', {
  schema: { pos: {default: 0.18}, rot: {default: 0.18}, scale: {default: 0.22} },
  init() { 
    this.p = new THREE.Vector3(); 
    this.q = new THREE.Quaternion(); 
    this.s = new THREE.Vector3(); 
  },
  tick() {
    const child = this.el.object3D;
    const parent = this.el.parentEl && this.el.parentEl.object3D;
    if (!parent) return;

    parent.getWorldPosition(this.p);
    parent.getWorldQuaternion(this.q);
    parent.getWorldScale(this.s);

    child.position.lerp(this.p, this.data.pos);
    child.quaternion.slerp(this.q, this.data.rot);
    child.scale.lerp(this.s, this.data.scale);
    child.updateMatrixWorld();
  }
});
</script>

<!-- Adaptive tracker: optimized for one-time detection -->
<script>
(function adaptiveTrackerRes(){
  const tracker = document.querySelector('ar-image-tracker');
  const cam = document.querySelector('ar-camera-source');
  if (!tracker || !cam) return;

  // Ensure camera is high; start tracker at high resolution for better detection
  cam.setAttribute('resolution', 'lg');
  tracker.setAttribute('resolution', 'lg');
  tracker.setAttribute('database-size', 'lg');

  let trackerDisabled = false;
  let timer = 0;
  
  document.addEventListener('artargetfound', (ev)=>{
    const ref = ev.detail && ev.detail.referenceImage;
    if (ref && (ref.name === 'face-target' || ref.name === 'frog-target')) {
      if (!trackerDisabled) {
        clearTimeout(timer);
        timer = setTimeout(()=> {
          tracker.setAttribute('resolution','lg');
          // Keep tracker enabled for dual target support
          console.log(`Target ${ref.name} anchored - tracker remains active for dual targets`);
        }, 1000);
      }
    }
  });
})();
</script>

<!-- Camera focus/zoom for small marker recognition -->
<script>
(function tuneCamera() {
  // Reintenta hasta que el <video> tenga el stream
  let tries = 0;
  const tick = async () => {
    tries++;
    // Encantar usa internamente un <video>; buscamos uno visible
    const vid = document.querySelector('ar-viewport video, video');
    const track = vid && vid.srcObject && vid.srcObject.getVideoTracks && vid.srcObject.getVideoTracks()[0];
    if (!track) { if (tries < 30) setTimeout(tick, 300); return; }

    const caps = (track.getCapabilities && track.getCapabilities()) || {};
    const adv = [];

    // foco continuo / exposiciÃ³n / balance blancos (si el device lo soporta)
    if (caps.focusMode && caps.focusMode.includes('continuous')) adv.push({ focusMode: 'continuous' });
    if (caps.exposureMode && caps.exposureMode.includes('continuous')) adv.push({ exposureMode: 'continuous' });
    if (caps.whiteBalanceMode && caps.whiteBalanceMode.includes('continuous')) adv.push({ whiteBalanceMode: 'continuous' });

    // zoom suave inicial (hasta 2.5x si se permite)
    if (caps.zoom) {
      const z = Math.min(caps.zoom.max || 2.5, 2.5);
      adv.push({ zoom: z });
    }

    try { await track.applyConstraints({ advanced: adv }); }
    catch(e) { /* silencioso: algunos navegadores ignoran campos no soportados */ }
  };
  tick();
})();
    
    // Setup onboarding button event listener
    document.addEventListener('DOMContentLoaded', () => {
      const startArBtn = document.getElementById('start-ar-btn');
      if (startArBtn) {
        startArBtn.addEventListener('click', ARtedita.hideOnboarding);
        startArBtn.addEventListener('touchend', ARtedita.hideOnboarding);
      }
    });
</script>

    <!-- CRT Terminal Onboarding Overlay -->
    <div id="onboarding-overlay">
        <div class="crt-screen">
            <!-- Screen Burn Effect -->
            <div class="screen-burn"></div>
            
            <!-- Terminal Header -->
            <div class="terminal">
                <h2>ARtEdita</h2>
                <p>AUGMENTED REALITY SYSTEM v2.1</p>
            </div>
            
            <!-- Instructions Content -->
            <div class="onboarding-instructions">
                <div class="instruction-box">
                    <h3>Instrucciones</h3>
                    
                    <div>
                        <p>Apunta tu cÃ¡mara a una de las caras de tu <strong>BrickCanvas</strong> y espera unos segundos para desbloquear tu experiencia 3D.</p>
                        <p>AsegÃºrate de enmarcarlo dentro de la cabeza guÃ­a y de tener buena iluminaciÃ³n.</p>
                    </div>
                    
                    <!-- Button inside the instructions box -->
                    <div style="text-align: center;">
                        <button id="start-ar-btn">
                            [ INICIAR SISTEMA ]
                        </button>
                    </div>
                </div>
            </div>
            
        </div>
    </div>

</body>
</html>
