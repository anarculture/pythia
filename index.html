<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1, maximum-scale=1">
    <title>ARtedita 3D Viewer</title>
    <!-- Local, version-pinned builds recommended for production -->
    <script src="encantar.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe@1.6.0/dist/aframe-v1.6.0.min.js"></script>
    <script src="aframe-with-encantar.js"></script>

    <!-- Performance Optimization: Cap device pixel ratio -->
    <script>
      (function capDPR () {
        const MAX_DPR = 1.5; // Balance between quality and performance
        const current = window.devicePixelRatio || 1;
        if (current > MAX_DPR) {
          Object.defineProperty(window, 'devicePixelRatio', { get: () => MAX_DPR });
        }
      })();
    </script>
    <style>
        /* Reset */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden; background: transparent;
            font-family: Arial, sans-serif;
            position: fixed; top: 0; left: 0;
        }
        @media (max-width: 768px) {
            html, body { height: 100vh; height: -webkit-fill-available; }
        }

        /* Fullscreen A-Frame/AR */
        a-scene, ar-viewport, ar-hud {
            width: 100vw !important;
            height: 100vh !important;
            height: -webkit-fill-available !important;
            position: fixed !important;
            top: 0 !important; left: 0 !important;
        }
        a-scene { z-index: 1 !important; }
        ar-hud { z-index: 1000 !important; }
        
        /* Ensure AR viewport is visible */
        ar-viewport {
            background: transparent !important;
            z-index: 2 !important;
        }

        /* Aim overlay glow effect */
        #aim-overlay.glow-exit {
            animation: glowAndFade 1.5s ease-out forwards;
        }
        
        @keyframes glowAndFade {
            0% {
                opacity: 1;
                filter: drop-shadow(0 0 0px #FFD700);
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                opacity: 0.8;
                filter: drop-shadow(0 0 30px #FFD700) drop-shadow(0 0 60px #FFD700);
                transform: translate(-50%, -50%) scale(1.1);
            }
            100% {
                opacity: 0;
                filter: drop-shadow(0 0 50px #FFD700) drop-shadow(0 0 100px #FFD700);
                transform: translate(-50%, -50%) scale(1.3);
            }
        }

        /* Aim overlay (LEGO) */
        #aim-overlay {
            position: fixed !important;
            top: 50% !important; left: 50% !important;
            transform: translate(-50%, -50%) !important;
            width: 80vmin !important; height: auto !important;
            z-index: 1001 !important; pointer-events: none !important;
            transition: opacity .25s ease;
        }
        #aim-overlay svg {
            width: 100% !important;
            height: auto !important;
        }

        /* Enhanced animations */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.3); }
        }
        
        @keyframes progressPulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        @keyframes scanPulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }
        
        @keyframes slideInUp {
            from { transform: translateY(30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes fadeInScale {
            from { transform: scale(0.9); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        /* Missing animations used by JavaScript */
        .fade-out { 
            opacity: 0 !important; 
            transition: opacity 0.5s ease; 
        }
        
        @keyframes fadeIn { 
            from { opacity: 0; } 
            to { opacity: 1; } 
        }
        
        #aim-overlay.hidden { opacity: 0; pointer-events: none; }
        
        /* Enhanced aim overlay with better visibility */
        #aim-overlay {
            animation: fadeInScale 0.5s ease-out;
        }
        
        /* Improved mobile touch targets */
        @media (max-width: 768px) {
            button, .touch-target {
                min-height: 48px;
                padding: 12px 24px;
            }
        }
        
        
        /* Particle burst animation for model unlock */
        .particle-burst {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 300px;
            pointer-events: none;
            z-index: 6000;
        }
        
        .particle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #FFD700;
            border-radius: 50%;
            opacity: 0;
            box-shadow: 0 0 8px #FFD700;
        }
        
        @keyframes sparkBurst {
            0% {
                opacity: 1;
                transform: scale(0) rotate(0deg);
                filter: brightness(2);
            }
            50% {
                opacity: 1;
                filter: brightness(1.5);
            }
            100% {
                opacity: 0;
                transform: scale(1) rotate(360deg);
                filter: brightness(0.5);
            }
        }
        
        @keyframes centerFlash {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0);
                background: radial-gradient(circle, #FFD700 0%, transparent 70%);
            }
            30% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(1.5);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(3);
            }
        }
        
        .center-flash {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 5900;
            animation: centerFlash 1s ease-out;
        }
        
        
        /* Unified button styles - eliminates duplication */
        .ar-button {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            color: #000;
            border: none;
            padding: 1rem 2rem;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
            min-width: 160px;
        }
        
        .ar-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.4);
        }
        
        .ar-button:active {
            transform: translateY(-2px);
        }
        
        
        /* CRT Terminal Loading Screen Styles */
        .crt-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center, #001100 0%, #000800 50%, #000000 100%);
            border-radius: 0;
            box-shadow: 
                inset 0 0 100px rgba(0, 255, 0, 0.1);
        }
        
        /* Scanlines Effect */
        .crt-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 255, 0, 0.03) 2px,
                rgba(0, 255, 0, 0.03) 4px
            );
            pointer-events: none;
            animation: scanlines 0.1s linear infinite;
        }
        
        /* Screen Flicker */
        @keyframes scanlines {
            0% { opacity: 1; }
            50% { opacity: 0.8; }
            100% { opacity: 1; }
        }
        
        /* Terminal Text Styling */
        .terminal {
            position: absolute;
            top: 35%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #00ff00;
            font-family: 'Courier New', monospace;
        }
        
        .terminal h2 {
            font-size: 2.5rem;
            letter-spacing: 6px;
            margin-bottom: 2rem;
            text-shadow: 
                0 0 5px #00ff00,
                0 0 10px #00ff00,
                0 0 15px #00ff00,
                0 0 20px #00ff00;
            animation: phosphorGlow 2s ease-in-out infinite alternate;
        }
        
        .terminal p {
            font-size: 0.9rem;
            opacity: 0.9;
            text-shadow: 
                0 0 3px #00ff00,
                0 0 6px #00ff00;
            line-height: 1.8;
            letter-spacing: 2px;
        }
        
        /* Phosphor Glow Animation */
        @keyframes phosphorGlow {
            0% { 
                text-shadow: 
                    0 0 5px #00ff00,
                    0 0 10px #00ff00,
                    0 0 15px #00ff00,
                    0 0 20px #00ff00;
            }
            100% { 
                text-shadow: 
                    0 0 8px #00ff00,
                    0 0 16px #00ff00,
                    0 0 24px #00ff00,
                    0 0 32px #00ff00,
                    0 0 40px #00ff00;
            }
        }
        
        /* Terminal Loading Bar */
        .loading-bar-container {
            position: absolute;
            top: 65%;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            text-align: left;
            font-family: 'Courier New', monospace;
        }
        
        .terminal-prompt {
            color: #00ff00;
            font-size: 0.8rem;
            margin-bottom: 10px;
            text-shadow: 0 0 5px #00ff00;
            letter-spacing: 1px;
        }
        
        .loading-bar {
            width: 100%;
            height: 24px;
            background: #001100;
            border: 2px solid #00ff00;
            border-radius: 0;
            position: relative;
            overflow: hidden;
            box-shadow: 
                inset 0 0 10px rgba(0, 255, 0, 0.2),
                0 0 15px rgba(0, 255, 0, 0.3);
        }
        
        .loading-progress {
            height: 100%;
            width: 0%;
            background: repeating-linear-gradient(
                90deg,
                #00ff00 0px,
                #00ff00 3px,
                #00cc00 3px,
                #00cc00 6px
            );
            transition: width 0.2s ease;
            position: relative;
            animation: terminalShimmer 0.8s infinite;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        
        @keyframes terminalShimmer {
            0%, 100% { 
                filter: brightness(1);
                box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            }
            50% { 
                filter: brightness(1.3);
                box-shadow: 0 0 20px rgba(0, 255, 0, 0.8);
            }
        }
        
        .loading-percentage {
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            color: #00ff00;
            margin-top: 15px;
            text-shadow: 0 0 5px #00ff00;
            letter-spacing: 1px;
        }
        
        /* Screen Burn Effect */
        .screen-burn {
            position: absolute;
            top: 30%;
            left: 45%;
            width: 200px;
            height: 50px;
            background: radial-gradient(ellipse, rgba(0, 255, 0, 0.05) 0%, transparent 70%);
            animation: burnFlicker 3s ease-in-out infinite;
        }
        
        @keyframes burnFlicker {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.1; }
        }
        
        /* Responsive design for CRT */
        @media (max-width: 768px) {
            .terminal h2 {
                font-size: 1.5rem;
                letter-spacing: 3px;
            }
            
            .terminal p {
                font-size: 0.7rem;
                letter-spacing: 1px;
            }
            
            .loading-bar-container {
                width: 350px;
            }
            
            .terminal-prompt {
                font-size: 0.7rem;
            }
        }
    </style>
</head>

<body>
<script>
  // ARtedita Application Namespace - eliminates global variable pollution
  window.ARtedita = {
    state: {
      loadingProgress: 0,
      stepIndex: 0,
      isReady: false,
      overlayPaused: false
    },
    
    // DOM elements cache
    elements: {},
    
    // Debug logging function for mobile
    debugLog: (message) => {
      const timestamp = new Date().toLocaleTimeString();
      const debugDiv = document.getElementById('debug-messages');
      if (debugDiv) {
        debugDiv.innerHTML += `<div>[${timestamp}] ${message}</div>`;
        debugDiv.scrollTop = debugDiv.scrollHeight;
      } else {
        console.log(`[DEBUG] ${message}`);
      }
    },
    
    // Initialize DOM elements cache
    initElements() {
      this.elements = {
        scene: document.querySelector('a-scene'),
        aimOverlay: document.getElementById('aim-overlay'),
        customLoader: document.getElementById('custom-loader'),
        progressBar: document.getElementById('progress-bar'),
        scanningIndicator: document.getElementById('scanning-indicator')
      };
    }
  };

  // Enhanced UX management with loading and status feedback
  document.addEventListener('DOMContentLoaded', () => {
    ARtedita.initElements();
    const { scene, aimOverlay, customLoader, progressBar } = ARtedita.elements;
    
    // Terminal loading steps
    ARtedita.loadingSteps = [
      { progress: 15, delay: 400, text: 'INITIALIZING SYSTEM...' },
      { progress: 35, delay: 600, text: 'LOADING CORE LIBRARIES...' },
      { progress: 55, delay: 800, text: 'PREPARING AR FRAMEWORK...' },
      { progress: 75, delay: 700, text: 'LOADING 3D ASSETS...' },
      { progress: 90, delay: 500, text: 'CONFIGURING CAMERA...' },
      { progress: 100, delay: 600, text: 'SYSTEM READY' }
    ];
    
    ARtedita.updateProgress = (progress) => {
      ARtedita.state.loadingProgress = Math.min(progress, 100);
      if (progressBar) {
        progressBar.style.width = ARtedita.state.loadingProgress + '%';
      }
      // Update terminal percentage display
      const loadingPercentage = document.getElementById('loading-percentage');
      if (loadingPercentage) {
        loadingPercentage.textContent = `] ${Math.floor(ARtedita.state.loadingProgress)}% COMPLETE`;
      }
    };
    
    ARtedita.processLoadingStep = () => {
      if (ARtedita.state.stepIndex < ARtedita.loadingSteps.length) {
        const step = ARtedita.loadingSteps[ARtedita.state.stepIndex];
        ARtedita.updateProgress(step.progress);
        
        // Update terminal loading text
        const loadingText = document.getElementById('loading-text');
        if (loadingText) loadingText.textContent = step.text;
        
        ARtedita.state.stepIndex++;
        setTimeout(ARtedita.processLoadingStep, step.delay);
      } else {
        // Final completion state
        const loadingPercentage = document.getElementById('loading-percentage');
        if (loadingPercentage) {
          loadingPercentage.textContent = '] 100% COMPLETE - SYSTEM READY';
        }
      }
    }
    
    ARtedita.processLoadingStep();
    
    // Real AR system loading detection
    ARtedita.waitForARReady = () => {
      console.log('Waiting for AR system to be fully ready...');
      
      // Check if A-Frame scene is loaded
      const checkARReady = () => {
        const scene = document.querySelector('a-scene');
        if (!scene) {
          console.log('A-Frame scene not found, waiting...');
          setTimeout(checkARReady, 100);
          return;
        }
        
        // Wait for scene to be loaded
        if (!scene.hasLoaded) {
          console.log('A-Frame scene not loaded yet, waiting...');
          scene.addEventListener('loaded', () => {
            console.log('A-Frame scene loaded, checking AR components...');
            ARtedita.checkARComponents();
          });
          return;
        }
        
        console.log('A-Frame scene already loaded, checking AR components...');
        ARtedita.checkARComponents();
      };
      
      setTimeout(checkARReady, 1000); // Give time for scene to initialize
    };
    
    ARtedita.checkARComponents = () => {
      const scene = document.querySelector('a-scene');
      const arCamera = document.querySelector('ar-camera-source');
      const arTracker = document.querySelector('ar-image-tracker');
      
      console.log('Checking AR components:', {
        scene: !!scene,
        camera: !!arCamera,
        tracker: !!arTracker
      });
      
      // Only listen for AR ready events - no timeout fallback
      scene.addEventListener('arready', () => {
        console.log('AR ready event received!');
        if (!ARtedita.state.loaderHidden) {
          ARtedita.state.loaderHidden = true;
          ARtedita.hideLoaderAndShowOnboarding();
        }
      });
    };
    
    ARtedita.hideLoaderAndShowOnboarding = () => {
      console.log('Hiding loader and showing onboarding');
      if (customLoader && customLoader.style.display !== 'none') {
        customLoader.classList.add('fade-out');
        setTimeout(() => {
          customLoader.style.display = 'none';
          // Show onboarding immediately after loader
          ARtedita.showOnboarding();
        }, 500);
      }
    };
    
    ARtedita.showOnboarding = () => {
      console.log('Showing onboarding overlay');
      const onboardingOverlay = document.getElementById('onboarding-overlay');
      if (onboardingOverlay) {
        onboardingOverlay.style.display = 'block';
        onboardingOverlay.style.animation = 'fadeIn 0.5s ease-out';
      }
    };
    
    ARtedita.hideOnboarding = () => {
      console.log('Hiding onboarding overlay');
      const onboardingOverlay = document.getElementById('onboarding-overlay');
      if (onboardingOverlay) {
        onboardingOverlay.classList.add('fade-out');
        setTimeout(() => {
          onboardingOverlay.style.display = 'none';
        }, 500);
      }
    };
    
    // Start real AR loading detection
    ARtedita.waitForARReady();
    
    
    
    
    
    
    
    // Enhanced AR event handling
    if (scene && aimOverlay) {
      // Overlay animations management
      const overlayAnims = aimOverlay.querySelectorAll('.stroke-main, .stroke-halo');
      const pauseOverlay = () => overlayAnims.forEach(n => n.style.animationPlayState = 'paused');
      const playOverlay = () => overlayAnims.forEach(n => n.style.animationPlayState = 'running');
      
      // AR session events
      scene.addEventListener('enter-vr', () => {
      });
      
      // AR ready event - remove duplicate handler
      // (Main AR ready handling is now in checkARComponents)
      
      // Persistent model tracking - anchor after first detection
      let modelAnchored = false;
      
      scene.addEventListener('artargetfound', (ev) => {
        console.log('üê∏ AR Target Found Event:', ev);
        ARtedita.debugLog('üê∏ AR Target Found Event detected!');
        const ref = ev.detail && ev.detail.referenceImage;
        console.log('üê∏ Reference image detected:', ref ? ref.name : 'none');
        ARtedita.debugLog(`üê∏ Reference: ${ref ? ref.name : 'none'}`);
        console.log('üê∏ Full reference object:', ref);
        if (ref && ref.name === 'frog-reference-image') {
          console.log('‚úÖ FROG REFERENCE MATCHED - Starting model display');
          ARtedita.debugLog('‚úÖ FROG REFERENCE MATCHED!');
          pauseOverlay();
          
          // Hide scanning indicator
          if (ARtedita.elements.scanningIndicator) {
            ARtedita.elements.scanningIndicator.style.display = 'none';
          }
          
          // Fade out aim overlay smoothly
          if (aimOverlay) {
            aimOverlay.style.transition = 'opacity 1s ease-out';
            aimOverlay.style.opacity = '0';
            setTimeout(() => aimOverlay.style.display = 'none', 1000);
          }
          
          // Show centered model immediately after first detection
          if (!ARtedita.state.modelAnchored) {
            const arRoot = document.getElementById('main-scene');
            if (arRoot) {
              arRoot.setAttribute('visible', 'false');
            }
            
            // Show centered model
            ARtedita.debugLog('üéØ Creating Kermit model...');
            ARtedita.showCenteredModel(ref.name);
            modelAnchored = true;
            ARtedita.debugLog('üéâ Model creation complete!');
            ARtedita.triggerParticleBurst();
            ARtedita.state.modelAnchored = true;
          }
        }
      });
      
      // Show centered model function
      ARtedita.showCenteredModel = (referenceImageName) => {
        console.log('Showing centered model for:', referenceImageName);
        const arRoot = document.getElementById('main-scene');
        const camera = document.querySelector('ar-camera');
        
        if (!arRoot || !camera) {
          console.error('Could not find AR elements');
          return;
        }
        
        // Create centered container directly in scene
        const centeredContainer = document.createElement('a-entity');
        centeredContainer.id = 'centered-model';
        
        // Position model centered in camera view (5 units back)
        centeredContainer.setAttribute('position', '0 0 -5');
        centeredContainer.setAttribute('scale', '1 1 1');
        
        // Create the model element based on reference image
        const centeredModel = document.createElement('a-gltf-model');
        
        if (referenceImageName === 'my-reference-image') {
          // Scene 1: Face model
          centeredModel.id = 'centered-face-model';
          centeredModel.setAttribute('src', 'base_basic_shaded.glb');
          centeredModel.setAttribute('position', '0 -1 0');
          centeredModel.setAttribute('scale', '1 1 1');
          centeredModel.setAttribute('animation', 'property: rotation; to: 0 360 0; loop: true; dur: 5000');
        } else if (referenceImageName === 'frog-reference-image') {
          // Scene 2: Dancing Kermit
          centeredModel.id = 'centered-kermit-model';
          centeredModel.setAttribute('src', 'kermit_the_frog_dancing_twerk.glb');
          centeredModel.setAttribute('position', '0 -1.2 0');
          centeredModel.setAttribute('scale', '0.8 0.8 0.8');
          centeredModel.setAttribute('animation-mixer', 'clip: *; loop: repeat; repetitions: Infinity');
          centeredModel.setAttribute('animation', 'property: rotation; to: 0 360 0; loop: true; dur: 8000');
        }
        centeredModel.setAttribute('shadow', 'cast: true; receive: true');
        
        // Create lights optimized for smaller model
        const ambientLight = document.createElement('a-light');
        ambientLight.setAttribute('type', 'ambient');
        ambientLight.setAttribute('color', '#ffffff');
        ambientLight.setAttribute('intensity', '1.8');
        
        const directionalLight = document.createElement('a-light');
        directionalLight.setAttribute('type', 'directional');
        directionalLight.setAttribute('position', '1.5 3 1.5');
        directionalLight.setAttribute('color', '#ffffff');
        directionalLight.setAttribute('intensity', '2.5');
        directionalLight.setAttribute('shadow', 'cast: true');
        
        const pointLight1 = document.createElement('a-light');
        pointLight1.setAttribute('type', 'point');
        pointLight1.setAttribute('position', '-0.8 1.5 0.8');
        pointLight1.setAttribute('color', '#FF5722');
        pointLight1.setAttribute('intensity', '20');
        pointLight1.setAttribute('decay', '2');
        
        const pointLight2 = document.createElement('a-light');
        pointLight2.setAttribute('type', 'point');
        pointLight2.setAttribute('position', '0.8 1.5 0.8');
        pointLight2.setAttribute('color', '#2196F3');
        pointLight2.setAttribute('intensity', '20');
        pointLight2.setAttribute('decay', '2');
        
        // Assemble the container
        centeredContainer.appendChild(centeredModel);
        centeredContainer.appendChild(ambientLight);
        centeredContainer.appendChild(directionalLight);
        centeredContainer.appendChild(pointLight1);
        centeredContainer.appendChild(pointLight2);
        
        // Add to scene
        scene.appendChild(centeredContainer);
        
        // Hide original AR-tracked model
        arRoot.setAttribute('visible', 'false');
        
        console.log('Centered model created and added to scene');
      };
      
      // Particle burst animation for unlock effect
      ARtedita.triggerParticleBurst = () => {
        console.log('Triggering particle burst animation');
        
        // Create center flash
        const centerFlash = document.createElement('div');
        centerFlash.className = 'center-flash';
        document.body.appendChild(centerFlash);
        
        // Create particle container
        const burstContainer = document.createElement('div');
        burstContainer.className = 'particle-burst';
        document.body.appendChild(burstContainer);
        
        // Create particles
        const particleCount = 20;
        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          
          // Random position within container
          const angle = (i / particleCount) * 2 * Math.PI + (Math.random() - 0.5) * 0.5;
          const distance = 50 + Math.random() * 100;
          const x = Math.cos(angle) * distance;
          const y = Math.sin(angle) * distance;
          
          particle.style.left = `calc(50% + ${x}px)`;
          particle.style.top = `calc(50% + ${y}px)`;
          
          // Random animation timing
          const delay = Math.random() * 0.3;
          const duration = 1.2 + Math.random() * 0.8;
          
          // Random gold tones
          const goldTones = ['#FFD700', '#FFA500', '#FF8C00', '#DAA520', '#B8860B'];
          const color = goldTones[Math.floor(Math.random() * goldTones.length)];
          particle.style.background = color;
          particle.style.boxShadow = `0 0 8px ${color}`;
          
          particle.style.animation = `sparkBurst ${duration}s ease-out ${delay}s forwards`;
          
          burstContainer.appendChild(particle);
        }
        
        // Clean up after animation
        setTimeout(() => {
          centerFlash.remove();
          burstContainer.remove();
        }, 2000);
      };
      
      
      
      // Error handling
      scene.addEventListener('ar-error', (ev) => {
      });
      
      // Camera ready event - use AR stack instead of manual getUserMedia
      scene.addEventListener('arready', () => {
      });
    }
    
    // Performance monitoring
    let frameCount = 0;
    let lastTime = performance.now();
    
    const monitorPerformance = () => {
      frameCount++;
      const currentTime = performance.now();
      
      if (currentTime - lastTime >= 5000) { // Check every 5 seconds
        const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
        
        if (fps < 20) {
        }
        
        frameCount = 0;
        lastTime = currentTime;
      }
      
      requestAnimationFrame(monitorPerformance);
    };
    
    // Start performance monitoring
    requestAnimationFrame(monitorPerformance);
  });
</script>

<body>
    <!-- CRT Terminal Loading Screen -->
    <div id="custom-loader">
        <div class="crt-screen">
            <!-- Screen Burn Effect -->
            <div class="screen-burn"></div>
            
            <!-- Terminal Text -->
            <div class="terminal">
                <h2>ARtEdita</h2>
                <p id="loading-text">INITIALIZING SYSTEM...</p>
            </div>
            
            <!-- Terminal Loading Bar -->
            <div class="loading-bar-container">
                <div class="terminal-prompt">LOADING: [</div>
                <div class="loading-bar">
                    <div class="loading-progress" id="progress-bar"></div>
                </div>
                <div class="loading-percentage" id="loading-percentage">] 0% COMPLETE</div>
            </div>
        </div>
    </div>





    <!-- Scanning Indicator -->
    <div id="scanning-indicator" style="
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 193, 7, 0.9);
        color: #000;
        padding: 10px 20px;
        border-radius: 20px;
        font-size: 14px;
        font-weight: 600;
        z-index: 4500;
        display: none;
        align-items: center;
        gap: 8px;
    ">
        <div style="
            width: 8px;
            height: 8px;
            background: #000;
            border-radius: 50%;
            animation: pulse 1.5s ease-in-out infinite;
        "></div>
        Buscando objetivo...
    </div>

    <!-- Debug Status Display -->
    <div id="debug-status" style="
        position: fixed;
        bottom: 120px;
        left: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.7);
        color: #00ff00;
        padding: 10px;
        border-radius: 8px;
        font-family: 'Courier New', monospace;
        font-size: 11px;
        z-index: 1000;
        max-height: 100px;
        overflow-y: auto;
        display: block;
        pointer-events: none;
    ">
        <div style="color: #FFD700; font-weight: bold; margin-bottom: 5px;">üê∏ FROG DEBUG STATUS</div>
        <div id="debug-messages">Waiting for AR system...</div>
    </div>

    <!-- A-Frame AR Scene -->
    <a-scene encantar="stats: false; gizmos: false" device-orientation-permission-ui="enabled: false">

        <!-- Sources of data -->
        <ar-sources>
            <ar-camera-source resolution="lg" facing-mode="environment"></ar-camera-source>
        </ar-sources>

        <!-- Trackers -->
        <ar-trackers>
            <ar-image-tracker resolution="lg" database-size="lg">
                <!-- <ar-reference-image name="my-reference-image" src="reference.png"></ar-reference-image> -->
                <ar-reference-image name="frog-reference-image" src="reference2.png"></ar-reference-image>
            </ar-image-tracker>
        </ar-trackers>

        <!-- AR Viewport -->
        <ar-viewport>
            <ar-hud>
                <!-- LEGO head aim overlay -->
                <div id="aim-overlay">
  <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" style="background:none">
    <defs>
      <filter id="haloLite" x="-30%" y="-30%" width="160%" height="160%">
        <feGaussianBlur in="SourceGraphic" stdDeviation="5" />
      </filter>
      
      <!-- CRT Scanlines Pattern -->
      <pattern id="crtScanlines" x="0" y="0" width="100" height="4" patternUnits="userSpaceOnUse">
        <rect width="100" height="2" fill="rgba(0, 255, 0, 0.03)"/>
        <rect y="2" width="100" height="2" fill="transparent"/>
      </pattern>
      
      <!-- CRT Background Gradient -->
      <radialGradient id="crtBackground" cx="50%" cy="50%" r="70%">
        <stop offset="0%" stop-color="#001100" stop-opacity="0.8"/>
        <stop offset="50%" stop-color="#000800" stop-opacity="0.9"/>
        <stop offset="100%" stop-color="#000000" stop-opacity="1"/>
      </radialGradient>
      
      <!-- Combined CRT Fill -->
      <pattern id="crtFill" x="0" y="0" width="100" height="100" patternUnits="userSpaceOnUse">
        <rect width="100" height="100" fill="url(#crtBackground)"/>
        <rect width="100" height="100" fill="url(#crtScanlines)"/>
      </pattern>
    </defs>

    <style>
      .stroke-main {
        /* animation + styling still via CSS */
        stroke: #00ff00;
        stroke-width: 4.5;
        vector-effect: non-scaling-stroke;
        stroke-linejoin: round;
        stroke-linecap: round;
        animation: mainPulse 2.2s ease-in-out infinite;
      }
      .stroke-halo {
        stroke: #00ff00;
        stroke-width: 11;
        opacity: .5;
        vector-effect: non-scaling-stroke;
        stroke-linejoin: round;
        stroke-linecap: round;
        animation: haloPulse 2.2s ease-in-out infinite;
      }
      @keyframes mainPulse {
        0% { stroke: #00ff00; }
        50% { stroke: #33ff33; }
        100% { stroke: #00ff00; }
      }
      @keyframes haloPulse {
        0% { opacity: .4; stroke: #00cc00; }
        50% { opacity: .75; stroke: #33ff33; }
        100% { opacity: .4; stroke: #00cc00; }
      }
      
      /* CRT Scanning effect */
      @keyframes scanLine {
        0% { transform: translateY(0px); opacity: 0.8; }
        50% { opacity: 1; }
        100% { transform: translateY(60px); opacity: 0.8; }
      }
      @media (prefers-reduced-motion: reduce) {
        .stroke-main, .stroke-halo { animation: none; }
      }
    </style>

    <!-- CRT Background Fill -->
    <g fill="url(#crtFill)" fill-opacity="0.9">
      <rect x="15" y="20" width="70" height="60" rx="18" ry="18"/>
      <rect x="38" y="10" width="24" height="12" rx="3" ry="3"/>
      <rect x="33" y="80" width="34" height="10" rx="3" ry="3"/>
    </g>
    
    <!-- Animated Scanning Line -->
    <g>
      <line x1="33" y1="38" x2="67" y2="38" stroke="#00ff00" stroke-width="0.5" opacity="0.8">
        <animateTransform attributeName="transform" type="translate" 
                         values="0,0; 0,24; 0,0" dur="2s" repeatCount="indefinite"/>
        <animate attributeName="opacity" values="0.8;1;0.8" dur="2s" repeatCount="indefinite"/>
      </line>
    </g>

    <!-- HALO: force no fill via attribute -->
    <g style="filter:url(#haloLite);">
      <rect class="stroke-halo" x="15" y="20" width="70" height="60" rx="18" ry="18" fill="none"/>
      <rect class="stroke-halo" x="38" y="10" width="24" height="12" rx="3" ry="3" fill="none"/>
      <rect class="stroke-halo" x="33" y="80" width="34" height="10" rx="3" ry="3" fill="none"/>
    </g>

    <!-- OUTLINE: force no fill via attribute -->
    <g>
      <rect class="stroke-main" x="15" y="20" width="70" height="60" rx="18" ry="18" fill="none"/>
      <rect class="stroke-main" x="38" y="10" width="24" height="12" rx="3" ry="3" fill="none"/>
      <rect class="stroke-main" x="33" y="80" width="34" height="10" rx="3" ry="3" fill="none"/>
    </g>
  </svg>
            </div>
        </ar-hud>
    </ar-viewport>

    <!-- AR Camera -->
    <ar-camera></ar-camera>

        <!-- MAIN AR SCENE (wrapped in smoothing container) -->
        <ar-root id="main-scene" reference-image="my-reference-image" visible="true">
            <!-- Smoothed container for stability -->
            <a-entity id="smoothed" smooth-pose="pos:0.18; rot:0.18; scale:0.22">
              <a-gltf-model id="face-model"
                            src="base_basic_shaded.glb"
                            position="0 -1 0"
                            scale="1 1 1"
                            animation="property: rotation; to: 0 360 0; loop: true; dur: 5000"
                            shadow="cast: true; receive: true">
              </a-gltf-model>

              <a-light type="ambient" color="#ffffff" intensity="2.51"></a-light>
              <a-light type="directional" position="2 4 2" color="#ffffff" intensity="3.14" shadow="cast: true"></a-light>
              <a-light type="point" position="-1 2 1" color="#4CAF50" intensity="30" decay="2"></a-light>
              <a-light type="point" position="1 2 1" color="#2196F3" intensity="30" decay="2"></a-light>
            </a-entity>
        </ar-root>

    </a-scene>

<!-- Pose smoothing component -->
<script>
AFRAME.registerComponent('smooth-pose', {
  schema: { pos:{default:0.18}, rot:{default:0.18}, scale:{default:0.22} },
  init(){ this.p=new THREE.Vector3(); this.q=new THREE.Quaternion(); this.s=new THREE.Vector3(); },
  tick(){
    const child = this.el.object3D;
    const parent = this.el.parentEl && this.el.parentEl.object3D;
    if (!parent) return;

    parent.getWorldPosition(this.p);
    parent.getWorldQuaternion(this.q);
    parent.getWorldScale(this.s);

    child.position.lerp(this.p, this.data.pos);
    child.quaternion.slerp(this.q, this.data.rot);
    child.scale.lerp(this.s, this.data.scale);
    child.updateMatrixWorld();
  }
});
</script>

<!-- Adaptive tracker: optimized for one-time detection -->
<script>
(function adaptiveTrackerRes(){
  const tracker = document.querySelector('ar-image-tracker');
  const cam = document.querySelector('ar-camera-source');
  if (!tracker || !cam) return;

  // Ensure camera is high; start tracker at high resolution for better detection
  cam.setAttribute('resolution', 'lg');
  tracker.setAttribute('resolution', 'lg');
  tracker.setAttribute('database-size', 'lg');

  let trackerDisabled = false;
  let timer = 0;
  
  document.addEventListener('artargetfound', (ev)=>{
    const ref = ev.detail && ev.detail.referenceImage;
    if (ref && ref.name !== 'frog-reference-image') return;
    
    if (!trackerDisabled) {
      clearTimeout(timer);
      timer = setTimeout(()=> {
        tracker.setAttribute('resolution','lg');
        // Disable tracker after model is anchored (3 seconds total)
        setTimeout(() => {
          console.log('Disabling tracker - model is now persistent');
          tracker.setAttribute('enabled', 'false');
          trackerDisabled = true;
        }, 2000);
      }, 1000);
    }
  });
})();
</script>

<!-- Camera focus/zoom for small marker recognition -->
<script>
(function tuneCamera() {
  // Reintenta hasta que el <video> tenga el stream
  let tries = 0;
  const tick = async () => {
    tries++;
    // Encantar usa internamente un <video>; buscamos uno visible
    const vid = document.querySelector('ar-viewport video, video');
    const track = vid && vid.srcObject && vid.srcObject.getVideoTracks && vid.srcObject.getVideoTracks()[0];
    if (!track) { if (tries < 30) setTimeout(tick, 300); return; }

    const caps = (track.getCapabilities && track.getCapabilities()) || {};
    const adv = [];

    // foco continuo / exposici√≥n / balance blancos (si el device lo soporta)
    if (caps.focusMode && caps.focusMode.includes('continuous')) adv.push({ focusMode: 'continuous' });
    if (caps.exposureMode && caps.exposureMode.includes('continuous')) adv.push({ exposureMode: 'continuous' });
    if (caps.whiteBalanceMode && caps.whiteBalanceMode.includes('continuous')) adv.push({ whiteBalanceMode: 'continuous' });

    // zoom suave inicial (hasta 2.5x si se permite)
    if (caps.zoom) {
      const z = Math.min(caps.zoom.max || 2.5, 2.5);
      adv.push({ zoom: z });
    }

    try { await track.applyConstraints({ advanced: adv }); }
    catch(e) { /* silencioso: algunos navegadores ignoran campos no soportados */ }
  };
  tick();
})();
    
    // Setup onboarding button event listener
    document.addEventListener('DOMContentLoaded', () => {
      const startArBtn = document.getElementById('start-ar-btn');
      if (startArBtn) {
        startArBtn.addEventListener('click', ARtedita.hideOnboarding);
        startArBtn.addEventListener('touchend', ARtedita.hideOnboarding);
      }
    });
</script>

    <!-- CRT Terminal Onboarding Overlay -->
    <div id="onboarding-overlay" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #000;
        display: none;
        z-index: 3000;
        overflow: hidden;
    ">
        <div class="crt-screen">
            <!-- Screen Burn Effect -->
            <div class="screen-burn"></div>
            
            <!-- Terminal Header -->
            <div class="terminal" style="top: 15%;">
                <h2 style="font-size: 2.5rem; margin-bottom: 1rem;">ARtEdita</h2>
                <p style="font-size: 0.9rem; opacity: 0.7;">AUGMENTED REALITY SYSTEM v2.1</p>
            </div>
            
            <!-- Instructions Content -->
            <div style="
                position: absolute;
                top: 40%;
                left: 50%;
                transform: translateX(-50%);
                text-align: center;
                color: #00ff00;
                font-family: 'Courier New', monospace;
                width: 85%;
                max-width: 700px;
            ">
                <div style="
                    border: 2px solid #00ff00;
                    padding: 2rem;
                    background: rgba(0, 17, 0, 0.3);
                    box-shadow: 
                        inset 0 0 20px rgba(0, 255, 0, 0.1),
                        0 0 20px rgba(0, 255, 0, 0.2);
                ">
                    <h3 style="
                        font-size: 1.2rem;
                        margin-bottom: 1.5rem;
                        text-shadow: 0 0 10px #00ff00;
                        letter-spacing: 2px;
                        color: #00ff00;
                    ">Instrucciones</h3>
                    
                    <div style="
                        text-align: center;
                        font-size: 1rem;
                        line-height: 1.6;
                        margin-bottom: 1.5rem;
                        letter-spacing: 1px;
                    ">
                        <p style="margin-bottom: 1.5rem;">Apunta tu c√°mara a una de las caras de tu <strong>BrickCanvas</strong> y espera unos segundos para desbloquear tu experiencia 3D.</p>
                        <p style="font-size: 0.85rem; opacity: 0.9; margin-bottom: 1.5rem;">Aseg√∫rate de enmarcarlo dentro de la cabeza gu√≠a y de tener buena iluminaci√≥n.</p>
                    </div>
                    
                    <!-- Button inside the instructions box -->
                    <div style="text-align: center;">
                        <button id="start-ar-btn" style="
                            background: #001100;
                            color: #00ff00;
                            border: 2px solid #00ff00;
                            padding: 12px 30px;
                            font-family: 'Courier New', monospace;
                            font-size: 0.9rem;
                            letter-spacing: 2px;
                            cursor: pointer;
                            text-shadow: 0 0 5px #00ff00;
                            box-shadow: 
                                inset 0 0 10px rgba(0, 255, 0, 0.1),
                                0 0 15px rgba(0, 255, 0, 0.3);
                            transition: all 0.3s ease;
                        " onmouseover="this.style.background='#002200'; this.style.boxShadow='inset 0 0 15px rgba(0, 255, 0, 0.2), 0 0 25px rgba(0, 255, 0, 0.5)'" onmouseout="this.style.background='#001100'; this.style.boxShadow='inset 0 0 10px rgba(0, 255, 0, 0.1), 0 0 15px rgba(0, 255, 0, 0.3)'">
                            [ INICIAR SISTEMA ]
                        </button>
                    </div>
                </div>
            </div>
            
        </div>
    </div>

</body>
</html>
